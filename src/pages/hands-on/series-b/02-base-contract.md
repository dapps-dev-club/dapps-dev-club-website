---
templateKey: about-page
title: Base Contract - Smart Contract Development Patterns
date: 2020-02-11T10:36:00.000Z
updatedDate: 2020-02-11T10:36:00.000Z
draft: false
description: "Base contract. The second hands-on workshop in a series about smart contract development patterns: Ownable, pausable, and non-fungible token"
section: "hands-on"
authors:
  - bguiz
tags:
  - hands-on
---

WIP!

## Recap

In the previous workshop, we set up a project using
npm, Truffle, and Ganache.
Thus far, we have only had one default smart contract,
generated by Truffle.

In this workshop, we will create our own smart contract,
which will be the "base contract" used during the remainder
of the workshops in this series.

## Design specifications

Here are the design specifications for this smart contract.

- Name: Bolsillo Monstruos
- Each account can create a **Mon** in a 2 step process
  1. Create the Mon with a random "seed" for its genes. This account must pay an amount to the smart contract do so.
  2. Birth the Mon that was created earlier, after waiting a certain amount of time. The wait is to ensure randomisation of the new Mon's genes.
- Two accounts can reproduce Mons that they own, in a 2 step process
  1. The initiator account can send a "mate request" to the acceptor account. The initiating account must pay an amount to the smart contract do so.
  2. The acceptor account may then either accept or reject this mate request.
    - The acceptor rejects: The mate request is forgotten, and a partial amount previously paid by the initiator is paid to the acceptor, with the smart contract retaining the remainder.
    - The acceptor accepts: After waiting a certain amount of time. The genes of the initiator's Mon and the acceptor's Mon are spliced together, in a manner inspired by DNA in biology, and creates + births a new Mon that probabilistically has half of each of its parent Mons' genes. The wait is to ensure randomisation of the splicing process. The mate request is is fulfilled, and a partial amount previously paid by the initiator is paid to the acceptor, with the smart contract retaining the remainder
- This contract may designate an owner
  - The owner can withdraw funds stored by the smart contract
  - The owner can pause a subset of the functions of this smart contract
- One account may send a Mon that it owns to another account.

## Implementation plan

In this workshop, we will:

- Create a new smart contract, `Bolsilmon.sol`
- Create a Truffle deployment for the `Bolsilmon` smart contract
- Define a `struct` named `Mon` to represent each Mon
- Define mappings and related state variables to track the Mons' creations and births
- Define a `createMon` function for the first step in the Mon creation process
- Define a `birthMon` function for the second step in the Mon creation process
- Define a `struct` named `MonMate` to represent each mate request
- Define mappings and related state variables to track the mate requests
- Define a `mateRequest` function for the first step in the mate process, to be called by the initiator
- Define a `geneSplice` function to compute the randomised genes, for internal use in the mate process
- Define a `mateAccept` function for the second step in the mate process, to be called by the acceptor
- Define a `mateReject` function for the alternative second step in the mate process, to be called by the acceptor
- Define an `ownerWithdrawal` function that enables the fees collected by the smart contract to be withdrawn by its owner

In subsequent workshops, we will:

- Create a new smart contract, `Ownable.sol`
- This implements the `Ownable` pattern
  - Allows for ownership to be transferred, and accepted
  - Paves the way for future restrictions that certain function invocations may only be performed by its owner
- Modify the `Bolsilmon` contract to be `Ownable`
- Create a new smart contract, `Pausable.sol`
- This implements the `Pausable` pattern
  - Allows the owner, exclusively, toggle the paused state
  - Paves the way for future restrictions that certain functions invocations may only be performed by its owner
- Modify the `Bolsilmon` contract to be `Pausable`, which in turn is still `Ownable`
- Modify `Bolsilmon` to import `ERC721` from Open Zeppelin
- This implements the ERC721 non-fungible token specification
- Modify existing functions to represent Mons as non-fungible tokens, and enable them to be transferred between accounts

## General notes

- We will endeavour to test all code that is written by us thoroughly
- We will endeavour to to use best practices, and avoid common pitfalls
- This workshop will be the longest one, however, it introduces very few new concepts for those that have already completed the first series
- The subsequent workshops will be be short relative to this first one, however, they do introduce new concepts for those that have already completed the first series
- The chief intent with these workshops is educational, the developed solutions here are merely referential, and by no means should you consider them audited or ready for production/ mainnet deployment

## New smart contract

To create a new smart contract within a Truffle project,
we need to create not only the *smart contract*,
but also the *migration script* for it.

### Contract and migration files

We do so by creating an empty `.sol` file in the `contracts` folder,
and by making a copy of the existing file within the `migrations` folder.

```bash
touch contracts/Bolsilmon.sol
cp migrations/1_initial_migration.js migrations/2_bolsilmon.js
```

Edit the smart contract file to give it the following contents:

```solidity
pragma solidity 0.5.16;

contract Bolsilmon {
  constructor()
    public
  {
    // do nothing
  }
}

```

For the migrations file, you only need to replace all occurrences
of `Migrations` with `Bolsilmon`.

```diff
--- migrations/2_bolsilmon.js
+++ migrations/2_bolsilmon.js
@@ -1,5 +1,5 @@
-const Migrations = artifacts.require("Migrations");
+const Bolsilmon = artifacts.require("Bolsilmon");

 module.exports = function(deployer) {
-  deployer.deploy(Migrations);
+  deployer.deploy(Bolsilmon);
 };

```

### Compile empty contract

At this point you, have a smart contract that does absolutely nothing,
yet is a minimum viable one for deployment.

Let's go ahead and deploy it!

Execute `npm run compile`, and Truffle will run `solc`,
and you should see output similar to the following:

```bash
$ npm run compile

> smart-contract-dev-patterns-workshop@0.0.0 compile /home/bguiz/code/dadc/smart-contract-dev-patterns-workshop
> truffle compile


Compiling your contracts...
===========================
> Compiling ./contracts/Bolsilmon.sol
> Artifacts written to /home/bguiz/code/dadc/smart-contract-dev-patterns-workshop/build/contracts
> Compiled successfully using:
   - solc: 0.5.16+commit.9c3226ce.Emscripten.clang

```

You will notice that there is a new file,
`build/contracts/Bolsilmon.json`,
which is generated by Truffle.
Take a look in the "Contracts" tab of Ganache,
and you should see that `Migrations` has an address,
whereas `Bolsilmon` does not, because it has not been deployed yet.

![New smart contract - After compile before deploy - Ganache contracts](./02-after-compile-before-deploy-ganache-contracts.png)

## Quick Links

This workshop is part of a series:

- [Start here](../01-start-here/)
- [Base contract](../02-base-contract/) &hellip; You are here.
- [Ownable](../03-ownable/)
- [Pausable](../04-pausable/)
- [Non-fungible token](../05-non-fungible-token/)
