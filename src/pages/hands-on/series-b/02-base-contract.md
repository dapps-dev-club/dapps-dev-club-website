---
templateKey: about-page
title: Base Contract - Smart Contract Development Patterns
date: 2020-02-11T10:36:00.000Z
updatedDate: 2020-02-11T10:36:00.000Z
draft: false
description: "Base contract. The second hands-on workshop in a series about smart contract development patterns: Ownable, pausable, and non-fungible token"
section: "hands-on"
authors:
  - bguiz
tags:
  - hands-on
---

WIP!

## Recap

In the previous workshop, we set up a project using
npm, Truffle, and Ganache.
Thus far, we have only had one default smart contract,
generated by Truffle.

In this workshop, we will create our own smart contract,
which will be the "base contract" used during the remainder
of the workshops in this series.

## Design specifications

Here are the design specifications for this smart contract.

- Name: Bolsillo Monstruos
- Each account can create a **Mon** in a 2 step process
  1. Create the Mon with a random "seed" for its genes. This account must pay an amount to the smart contract do so.
  2. Birth the Mon that was created earlier, after waiting a certain amount of time. The wait is to ensure randomisation of the new Mon's genes.
- Two accounts can reproduce Mons that they own, in a 2 step process
  1. The initiator account can send a "mate request" to the acceptor account. The initiating account must pay an amount to the smart contract do so.
  2. The acceptor account may then either accept or reject this mate request.
    - The acceptor rejects: The mate request is forgotten, and a partial amount previously paid by the initiator is paid to the acceptor, with the smart contract retaining the remainder.
    - The acceptor accepts: After waiting a certain amount of time. The genes of the initiator's Mon and the acceptor's Mon are spliced together, in a manner inspired by DNA in biology, and creates + births a new Mon that probabilistically has half of each of its parent Mons' genes. The wait is to ensure randomisation of the splicing process. The mate request is is fulfilled, and a partial amount previously paid by the initiator is paid to the acceptor, with the smart contract retaining the remainder
- This contract may designate an owner
  - The owner can withdraw funds stored by the smart contract
  - The owner can pause a subset of the functions of this smart contract
- One account may send a Mon that it owns to another account.

## Implementation plan

In this workshop, we will:

- Create a new smart contract, `Bolsilmon.sol`
- Create a Truffle deployment for the `Bolsilmon` smart contract
- Define a `struct` named `Mon` to represent each Mon
- Define mappings and related state variables to track the Mons' creations and births
- Define a `createMon` function for the first step in the Mon creation process
- Define a `birthMon` function for the second step in the Mon creation process
- Define a `struct` named `MonMate` to represent each mate request
- Define mappings and related state variables to track the mate requests
- Define a `mateRequest` function for the first step in the mate process, to be called by the initiator
- Define a `geneSplice` function to compute the randomised genes, for internal use in the mate process
- Define a `mateAccept` function for the second step in the mate process, to be called by the acceptor
- Define a `mateReject` function for the alternative second step in the mate process, to be called by the acceptor
- Define an `ownerWithdrawal` function that enables the fees collected by the smart contract to be withdrawn by its owner

In subsequent workshops, we will:

- Create a new smart contract, `Ownable.sol`
- This implements the `Ownable` pattern
  - Allows for ownership to be transferred, and accepted
  - Paves the way for future restrictions that certain function invocations may only be performed by its owner
- Modify the `Bolsilmon` contract to be `Ownable`
- Create a new smart contract, `Pausable.sol`
- This implements the `Pausable` pattern
  - Allows the owner, exclusively, toggle the paused state
  - Paves the way for future restrictions that certain functions invocations may only be performed by its owner
- Modify the `Bolsilmon` contract to be `Pausable`, which in turn is still `Ownable`
- Modify `Bolsilmon` to import `ERC721` from Open Zeppelin
- This implements the ERC721 non-fungible token specification
- Modify existing functions to represent Mons as non-fungible tokens, and enable them to be transferred between accounts

## General notes

- We will endeavour to test all code that is written by us thoroughly
- We will endeavour to to use best practices, and avoid common pitfalls
- This workshop will be the longest one, however, it introduces very few new concepts for those that have already completed the first series
- The subsequent workshops will be be short relative to this first one, however, they do introduce new concepts for those that have already completed the first series
- The chief intent with these workshops is educational, the developed solutions here are merely referential, and by no means should you consider them audited or ready for production/ mainnet deployment

## New smart contract

To create a new smart contract within a Truffle project,
we need to create not only the *smart contract*,
but also the *migration script* for it.

### Contract and migration files

We do so by creating an empty `.sol` file in the `contracts` folder,
and by making a copy of the existing file within the `migrations` folder.

```bash
touch contracts/Bolsilmon.sol
cp migrations/1_initial_migration.js migrations/2_bolsilmon.js
```

Edit the smart contract file to give it the following contents:

```solidity
pragma solidity 0.5.16;

contract Bolsilmon {
  constructor()
    public
  {
    // do nothing
  }
}

```

For the migrations file, you only need to replace all occurrences
of `Migrations` with `Bolsilmon`.

```diff
--- migrations/2_bolsilmon.js
+++ migrations/2_bolsilmon.js
@@ -1,5 +1,5 @@
-const Migrations = artifacts.require("Migrations");
+const Bolsilmon = artifacts.require("Bolsilmon");

 module.exports = function(deployer) {
-  deployer.deploy(Migrations);
+  deployer.deploy(Bolsilmon);
 };

```

### Compile empty contract

At this point you, have a smart contract that does absolutely nothing,
yet is a minimum viable one for deployment.

Let's go ahead and deploy it!

Execute `npm run compile`, and Truffle will run `solc`,
and you should see output similar to the following:

```bash
$ npm run compile

> smart-contract-dev-patterns-workshop@0.0.0 compile /home/bguiz/code/dadc/smart-contract-dev-patterns-workshop
> truffle compile


Compiling your contracts...
===========================
> Compiling ./contracts/Bolsilmon.sol
> Artifacts written to /home/bguiz/code/dadc/smart-contract-dev-patterns-workshop/build/contracts
> Compiled successfully using:
   - solc: 0.5.16+commit.9c3226ce.Emscripten.clang

```

You will notice that there is a new file,
`build/contracts/Bolsilmon.json`,
which is generated by Truffle.
Take a look in the "Contracts" tab of Ganache,
and you should see that `Migrations` has an address,
whereas `Bolsilmon` does not, because it has not been deployed yet.

![New smart contract - After compile before deploy - Ganache contracts](./02-after-compile-before-deploy-ganache-contracts.png)

### Deploy empty contract

Next, execute `npm run deploy`,
and Truffle will take this compiled contract,
and deploy it on the simulated blockchain running in Ganache.

You should see output similar to the following:

```bash
$ npm run deploy

> smart-contract-dev-patterns-workshop@0.0.0 deploy /home/bguiz/code/dadc/smart-contract-dev-patterns-workshop
> truffle migrate


Compiling your contracts...
===========================
> Everything is up to date, there is nothing to compile.



Starting migrations...
======================
> Network name:    'development'
> Network id:      5777
> Block gas limit: 0x6691b7


2_bolsilmon.js
==============

   Deploying 'Bolsilmon'
   ---------------------
   > transaction hash:    0xee340f6223f7057d38b4eed1a34af107f7bc55235fc9d2d9f08789bc4203dbe1
   > Blocks: 0            Seconds: 0
   > contract address:    0x51B2E14dd1A4b643dD3d72B33B819636886369EA
   > block number:        3
   > block timestamp:     1582010298
   > account:             0x42A9dbF577d2B2129605e2F1d9cC3B626E29351d
   > balance:             99.99245932
   > gas used:            71270
   > gas price:           20 gwei
   > value sent:          0 ETH
   > total cost:          0.0014254 ETH


   > Saving migration to chain.
   > Saving artifacts
   -------------------------------------
   > Total cost:           0.0014254 ETH


Summary
=======
> Total deployments:   1
> Final cost:          0.0014254 ETH

```

Commentary:

- See `Compiling your contracts` in the output.
  This is because Truffle checks if the deployed version is up to date.
  If it is not, it will automatically re-compile
  (and subsequently deploy this new copy, not the previously compiled version).
- See `Starting migrations` in the output.
  This is where your migrations script is run.
- See `Deploying 'Bolsilmon'` in the output.
  This is the result of the migration,
  showing the details of the deployment transaction.
  A smart contract deployment is a transaction,
  just like any other interaction with the blockchain.

Switch to Ganache, and look in the "Contracts" tab again.
This time you will notice that the the `Bolsilmon` smart contract
has indeed been deployed, and has an address.

![New smart contract - After compile after deploy - Ganache contracts](./02-after-compile-after-deploy-ganache-contracts.png)

### Version control for this step

Don't forget to commit and push these changes to the git remote!

```bash
git status
git add contracts/Bolsilmon.sol migrations/2_bolsilmon.js
git commit -m "feat: empty main contract with migration"
git tag -a step-02-01 $( git rev-parse HEAD ) -m "step-02-01"
git push origin master --tags

```

## Mon `struct`s and state variables

This smart contract needs to represent multiple Mons,
and therefore need to store data about all of them.
We will use `struct`s to model the state of an individual Mon,
and `uint256`s and `mapping`s to store the state of multiple Mons.

### Smart contract arrangement

Before we start with the above, a little housekeeping.
A little organisation up front paves the way for
easier to navigate code further along.

Modify `contracts/Bolsilmon.sol` to add the following comments:

```diff
--- contracts/Bolsilmon.sol
+++ contracts/Bolsilmon.sol
@@ -1,6 +1,15 @@
 pragma solidity 0.5.16;

 contract Bolsilmon {
+  // structs
+
+  // events
+
+  // state variables
+
+  // modifiers
+
+  // functions
   constructor()
     public
   {
```

In this workshop, we will be grouping the different elements
that the smart contract is comprised of by category:
`struct`, `event`, state variable, `modifier`, and `function`.
This makes it easier to find what we are looking for,
as we expect the size of this file to get quite large.

### The Mon struct

Under the section demarcated by `// structs`,
add the first one:

```solidity
  struct Mon {
    uint256 createBlock;
    bool born;
    bytes32 genes;
  }

```

Keep in mind that this point,
this smart contract does not yet store any state.
A `struct` merely defines a logical grouping
of state variables.

### A collection of Mons using state variables

Under the section demarcated by `// state variables`,
add these three:

```solidity
  uint256 public numMons = 0;
  mapping(uint256 => Mon) public mons;
  mapping(uint256 => address) public monCreators;

```

Using a combination of a `uint256` state variable
and a `mapping(uint256 => $STRUCT)` is a common pattern
used in Solidity for storing a collection of information.
This is what we have done with `numMons` and `mons`.

You may have noticed earlier that when we defined the `struct`,
it did not define a field named `address owner`.
If we had done this, when we have a Mon,
we can find out who its owner is by looking up a property:
e.g. `mon.owner`.

Instead, we have chosen to keep this information stored
in a separate `mapping` called `monCreators`.
This is done for a couple of reasons:

1. We would like to be able to look up a Mon's owner directly,
   without retrieving the full Mon `struct`.
2. This has implications at a later stage of the project,
   when we implement a non-fungible token standard,
   which may not be apparently just yet.
   We shall get to that in a later workshop.

At that this point, this smart contract does store some state.

Compile the smart contract to ensure that you have no compilation errors,
using `npm run compile`.
The output should be similar to the compile output we saw earlier.

## Quick Links

This workshop is part of a series:

- [Start here](../01-start-here/)
- [Base contract](../02-base-contract/) &hellip; You are here.
- [Ownable](../03-ownable/)
- [Pausable](../04-pausable/)
- [Non-fungible token](../05-non-fungible-token/)
